uses Plasmacore

$define TRANSITION_TIME 1

Display( "Main" ).screen = Launch()

#TODO: put dead check stuff in MyScreen

class Launch : Screen
  PROPERTIES
    ticks = 30 : Int32

  METHODS
    method init
      #Display.scale_to_fit(1024,768)

    method on_update
      ticks--
      if (ticks == 0)
        MainMenu
        TreeGame
        TransitionTo( GameScreen(), 0.5 )
      endIf
endClass

class GameScreen : Screen
  METHODS
    method apply_transition_offset
      if (transition_info)
        local info = transition_info.value
        local progress = info.eased_progress( &invert_ease_in )
        Display.offset += Display.size * ?:{Display.is_phone:1.37 || 1.0} * info.exit_vector * progress
        # 1.37 accounts for phone zoom
      endIf

    method on_start
      change_state( MainMenu )

    method on_transition_after_draw
      if (transition_info.value.exit_vector.is_zero)
        local info = transition_info.value
        Display.bounds.fill( info.color.with_alpha(info.eased_progress(&invert_ease_in)) )
      endIf
endClass

class CreditsMenu : BaseMenuState [singleton]
  METHODS
    method init
      Graphics.scale_to_fit( Anchor.CENTER )
      #menu = Menu(Corners(0,180,Display.size.x,Display.size.y - 40))
      menu = Menu( Box(Display.bounds.center.x,0,0,768) )
      menu.target = this
      menu.add(MenuImage("title_credits.png"))
      menu.add(MenuSpacer(XY(0,20)))

      menu.add( MenuText("The Light Before Xmas v1.0") )
      menu.add( MenuText("Copyright 2010, 2019 by Murphy McCauley") )
      menu.add( MenuText("Developed by Murphy McCauley in 2010") )
      menu.add( MenuText("Updated by Abe Pralle and Murphy McCauley in 2019") )
      menu.add( MenuText("With thanks to several inspirational Flash games") )
      menu.add(MenuSpacer(XY(0,20)))

      menu.add( MenuText("Full source code ") )
      menu.add( MenuText("github.com/MurphyMc/light-before-xmas") )
      menu.add(MenuSpacer(XY(0,20)))

      menu.add( MenuText("Wonderful music by Kevin MacLeod (incompetech.com)") )
      menu.add( MenuText("Available under Creative Commons: By Attribution 2.0 and 4.0.") )
      menu.add(MenuSpacer(XY(0,20)))

      menu.add( MenuText(''"Dance of the Sugar Plum Fairies"'') )
      menu.add( MenuText(''"Jingle Bells (Calm)"'') )
      menu.add( MenuText(''"Silent Night"'') )
      menu.add( MenuText(''"Oh Christmas Tree"'') )
      menu.add(MenuSpacer(XY(0,20)))

      menu.add( MenuText("Additional license details on GitHub") )
      menu.add(MenuSpacer(XY(0,20)))

      menu.add(MenuButton("Go Back"))
      menu.add(MenuSpacer(XY(0,20)))

      #method immediate_execute (action : Object)
      #println(".")
      #if (action == "Go Back")
        #        pop
        #TransitionToExitState( TRANSITION_TIME, &exit_vector=XY(-1,0) )
        #endIf
endClass

class BaseMenuState : ScreenState<<GameScreen>>, MyScreen, MenuHost
  PROPERTIES
    menu : Menu
    entry : Object

    last_not_dead = -1 : Int64
    countdown : Int32

  METHODS
    method on_resume
      menu.offset = XY.zero
      #menu.fly_in_right

    method on_start
      menu.offset = XY.zero
      #menu.fly_in_right

    method on_update
      Music.tick
      menu.update
      if (entry is null) return
      countdown--
      if (countdown > 0) return
      delayed_execute(entry)
      entry = null

    method delayed_execute (action : Object)
      # Override

    method immediate_execute (action : Object)
      # Override
      #menu.fly_out_left

    method check_dead->Logical
      if (last_not_dead == -1) last_not_dead = running_ms
      local dead = false
      if (running_ms - last_not_dead > 1000)
        Global.time_offset -= (running_ms - last_not_dead)
        dead = true
      endIf
      last_not_dead = running_ms
      return dead

    method on_draw
      if (check_dead) return
      Graphics.draw_background
      Graphics.scale_to_fill( Anchor.BOTTOM )
      FlakeManager.draw
      Graphics.scale_to_fit( Anchor.CENTER )
      screen.apply_transition_offset
      menu.draw

    method menu_selected (entry : MenuEntry, identifier : Object)
      this.entry = entry
      #immediate_execute(entry)
      TransitionToExitState( TRANSITION_TIME, &exit_vector=XY(-1,0) )
      countdown = 30

    method on (e : PointerEvent)
      menu.on(e)
endClass

class MainMenu : ScreenState<<GameScreen>>, MenuHost, MyScreen [singleton]
  PROPERTIES
    menu      : Menu
    action    : Object
    countdown : Int32
    #xform = Transform.identity : Transform #create_from(Radians(pi), XY(1,1), XY(1023,767)) : Transform
  METHODS
    method init
      #menu = Menu(Box(XY(Display.size.x/2,450),XY(0,748-450)))
      Graphics.scale_to_fit( Anchor.TOP )
      menu = Menu(Box(XY(Display.bounds.center.x,80),XY(0,748-180-20)))
      menu.target = this
      menu.add(MenuImage("main_title.png"))
      menu.add(MenuSpacer(40))
      menu.add(MenuButton("Start"))
      #menu.add(MenuButton("High Scores"))
      menu.add(MenuButton("Options"))
      menu.add(MenuButton("Credits"))
      TreeGame
      Music

    method on_start
      menu.offset = Display.center - XY(512,384)

    #method on_resume
      #menu.current_offset = Display.at(0.5,0)
      #menu.fly_in_right

    method on_update
      menu.update
      if (action is null) return
      countdown--
      if (countdown > 0) return
      local identifier = action
      action = null
      if (identifier == "Start")
        TransitionTo( TreeGame, TRANSITION_TIME, &exit_vector=XY(0,-1) )
      elseIf (identifier == "Options")
        TransitionToPushState( OptionsMenu, TRANSITION_TIME, &exit_vector=XY(-1,0) )
      elseIf (identifier == "Credits")
        TransitionToPushState( CreditsMenu, TRANSITION_TIME, &exit_vector=XY(1,0) )
      endIf

    method on_draw
      Graphics.draw_background
      Graphics.scale_to_fill( Anchor.BOTTOM )
      FlakeManager.draw
      Graphics.scale_to_fit( Anchor.TOP )
      screen.apply_transition_offset
      menu.draw

    method menu_selected (entry : MenuEntry, identifier : Object)
      #menu.fly_out_left
      action = identifier
      #countdown = 30

    method on (e : PointerEvent)
      menu.on(e)

    method on_resize
      TreeGame.on_resize
endClass

#{
class ScreenManager [singleton]
  PROPERTIES
    flipped = false : Logical
    xform = Transform.identity : Transform
    time_current = running_ms : Int64
    next_orientation = 0 : Int32
    orientation_time = running_ms : Int64
    flipping = false :Logical
    flip_time : Int64
  METHODS
    method init
#{ ABE
[if defined(IPHONE)]
      xform = Transform.create_from(Radians(pi), XY(1,1), Display.size - XY(1,1))#XY(1023,767))
      flipped = true
      Input.flip = true
      IPhone.orient = 3
[endIf]
}#
    method flip (v : Logical)
      if (v == flipped) return

      Input.flip = v
      flip_time = running_ms
      flipping = true
      #{
      if (v)
        xform = Transform.create_from(Radians(pi), XY(1,1), XY(1023,767))
      else
        xform = Transform.identity
      endIf
      }#

      #{ ABE
      if (v)
        IPhone.orient = 3
      else
        IPhone.orient = 1
      endIf
      }#

      flipped = v
    method update
      if (not flipping) return
      local p = (running_ms - flip_time) / 750.0 : Real64
      if (p > 1)
        p = 1
        flipping = false
      endIf
      if (not flipped)
        Transform.translate(Display.size * .5).push_camera_transform
        xform = Transform.create_from(Radians(-pi * (1 - p)), XY(1,1), XY(0,0))
        xform.push_camera_transform
        Transform.translate(Display.size * -.5).push_camera_transform
      else
        Transform.translate(Display.size * .5).push_camera_transform
        xform = Transform.create_from(Radians(pi * -p), XY(1,1), XY(0,0))#1023,767))
        xform.push_camera_transform
        Transform.translate(Display.size * -.5).push_camera_transform
        if (p == 1)
          xform = Transform.create_from(Radians(pi * p), XY(1,1), Display.size - XY(1,1))
        endIf
      endIf
endClass
}#

class MyScreen [aspect]
  METHODS
    #{ ABE
    method on (event : AccelerationEvent)
      #println(event.to_String + " " + event.orientation.to_String)
      local o = event.x.sign : Int32
      if (event.x.abs < 0.5) o = 0
      if (o != ScreenManager.next_orientation)
        ScreenManager.next_orientation = o
        ScreenManager.orientation_time = running_ms + 1000
      elseIf (o != 0)
        if (ScreenManager.orientation_time < running_ms)
          if (o == -1)
            ScreenManager.flip(false)
          else
            ScreenManager.flip(true)
          endIf
        endIf
      endIf

      insertUnderlying
    }#

    #{
    method on_draw
      if (ScreenManager.flipping)
        ScreenManager.update
      else
        ScreenManager.xform.push_camera_transform
      endIf
      insertUnderlying
      if (ScreenManager.flipping)
        local b = Box(0,-300,Display.size.x,300)
        b.fill(Color.BLACK)
        b = Box(-300,-300,300,Display.size.y+600)
        b.fill(Color.BLACK)
        b = Box(Display.size.x,-300,300,Display.size.y+600)
        b.fill(Color.BLACK)
        b = Box(0,Display.size.y,Display.size.x,300)
        b.fill(Color.BLACK)
      endIf
      }#
endClass

class OptionsMenu : ScreenState<<GameScreen>>, MenuHost, MyScreen [singleton]
  PROPERTIES
    menu      : Menu
    action    : MenuEntry
    countdown : Int32

  METHODS
    method init
      Graphics.scale_to_fit( Anchor.TOP )
      menu = Menu( Box(Display.bounds.center.x,180,0,768-(180+40)) )
      #menu = Menu(Corners(0,180,Display.bounds.center.x,Display.size.y - 40)) # XY(Display.size.x/2,500),XY(0,748-500)))
      menu.target = this
      menu.add(MenuImage("title_options.png"))
      menu.add(MenuSpacer(40))
      menu.add(MenuSpacer(20))
      menu.add(MenuButton("Turn Music Off"))
      menu.add(MenuButton("Turn Sound Off"))
      menu.add(MenuButton("Invert Swipe"))
      menu.add(MenuButton("Go Back"))
      menu.add(MenuSpacer(60))

    method on_start
      menu.offset = Display.center - XY(512,384)
      #menu.current_offset = XY.zero
      #menu.fly_in_right

    method on_update
      Music.tick
      menu.update
      if (action is null) return
      countdown--
      if (countdown > 0) return
      local identifier = action.item.identifier
      if (identifier == "Go Back")
        TransitionToExitState( TRANSITION_TIME, &exit_vector=XY(1,0) )
      elseIf (identifier == "Turn Music On")
        (action.item as MenuButton).text = "Turn Music Off"
        Music.paused = false
      elseIf (identifier == "Turn Music Off")
        (action.item as MenuButton).text = "Turn Music On"
        Music.paused = true
      elseIf (identifier == "Turn Sound On")
        (action.item as MenuButton).text = "Turn Sound Off"
        SFX.enabled = true
      elseIf (identifier == "Turn Sound Off")
        (action.item as MenuButton).text = "Turn Sound On"
        SFX.enabled = false
      elseIf (identifier == "Invert Swipe")
        (action.item as MenuButton).text = "Normal Swipe"
        TreeGame.invert_swipe = true
      elseIf (identifier == "Normal Swipe")
        (action.item as MenuButton).text = "Invert Swipe"
        TreeGame.invert_swipe = false
      endIf
      action = null

    method on_draw
      Graphics.draw_background
      Graphics.scale_to_fill( Anchor.BOTTOM )
      FlakeManager.draw
      Graphics.scale_to_fit( Anchor.TOP )
      screen.apply_transition_offset
      menu.draw

    method menu_selected (entry : MenuEntry, identifier : Object)
      action = entry
      countdown = 2
      #if (identifier == "Go Back")
        #menu.fly_out_left
        #countdown = 20
      #endIf

    method on(e : PointerEvent)
      menu.on(e)
endClass

class PauseMenu : ScreenState<<GameScreen>>, MenuHost, MyScreen [singleton]
  PROPERTIES
    menu : Menu
    action : MenuEntry
    countdown : Int32
  METHODS
    method init
      Graphics.scale_to_fit( Anchor.CENTER )
      menu = Menu( Box(Display.bounds.center.x,120,0,768-(100+80)) )
      menu.target = this
      menu.add(MenuImage("title_paused.png"))
      menu.add(MenuSpacer(30))
      menu.add(MenuButton("Resume"))
      menu.add(MenuButton("New Game"))
      menu.add(MenuButton("Main Menu"))
      menu.add(MenuSpacer(30))
      menu.add(MenuButton(select{Music.paused:"Turn Music On"||"Turn Music Off"}))
      menu.add(MenuButton(select{SFX.enabled:"Turn Sound Off"||"Turn Sound On"}))
      menu.add(MenuButton(select{TreeGame.invert_swipe:"Normal Swipe"||"Invert Swipe"}))

    method on_start
      menu.offset = Display.center - XY(512,384)

    method on_update
      Music.tick
      menu.update
      if (action is null) return
      countdown--
      if (countdown > 0) return
      local identifier = action.item.identifier
      if (identifier == "Resume")
        TransitionToExitState( TRANSITION_TIME, &exit_vector=XY(0,-1) )
      elseIf (identifier == "New Game")
        TreeGame.tree = Tree(17)
        TransitionToExitState( TRANSITION_TIME, &exit_vector=XY(0,-1) )
      elseIf (identifier == "Main Menu")
        TransitionTo( MainMenu, TRANSITION_TIME, &exit_vector=XY(0,1) )
      elseIf (identifier == "Turn Music On")
        (action.item as MenuButton).text = "Turn Music Off"
        Music.paused = false
      elseIf (identifier == "Turn Music Off")
        (action.item as MenuButton).text = "Turn Music On"
        Music.paused = true
      elseIf (identifier == "Turn Sound On")
        (action.item as MenuButton).text = "Turn Sound Off"
        SFX.enabled = true
      elseIf (identifier == "Turn Sound Off")
        (action.item as MenuButton).text = "Turn Sound On"
        SFX.enabled = false
      elseIf (identifier == "Invert Swipe")
        (action.item as MenuButton).text = "Normal Swipe"
        TreeGame.invert_swipe = true
      elseIf (identifier == "Normal Swipe")
        (action.item as MenuButton).text = "Invert Swipe"
        TreeGame.invert_swipe = false
      endIf
      action = null

    method on_draw
      Graphics.draw_background
      Graphics.scale_to_fill( Anchor.BOTTOM )
      FlakeManager.draw
      Graphics.scale_to_fit( Anchor.CENTER )

      screen.apply_transition_offset
      menu.draw

    method menu_selected (entry : MenuEntry, identifier : Object)
      action = entry
      countdown = 2
      #if (identifier == "Resume" or identifier == "New Game" or identifier == "Main Menu")
        #menu.fly_out_bottom
        #countdown = 20
      #endIf

    method on(e : PointerEvent)
      menu.on(e)
endClass

class MenuItem [abstract]
  METHODS
    method on_in
    method on_out
    method on_down
    method on_up
    method draw (position : XY)
    method update
    method size->XY
      return XY(0,0)
    method hitbox->Box
      return Box(0,0,0,0)
    method identifier->Object
      return this
endClass

class MenuHost [aspect]
  METHODS
    method menu_selected (entry : MenuEntry, identifier : Object)
endClass

class MenuImage : MenuItem
  PROPERTIES
    img : Image

  METHODS
    method init (img)
      img.anchor = Anchor.TOP_LEFT

    method init (filename : String)
      init( Image(filename) )

    method draw (position : XY)
      img.draw(position)

    method size->XY
      return img.size
endClass

class MenuSpacer : MenuItem
  PROPERTIES
    _size : XY
  METHODS
    method init (_size)
    method init (s : Int32)
      _size = XY(s, s)
    method size->XY
      return _size
endClass

class MenuButton : MenuItem
  PROPERTIES
    text            : String
    highlight       : Logical

    cur_scale       : Real64
    target_scale    : Real64
    locked = false  : Logical

    HIGHLIGHT = .99 : Real64
    NORMAL = .90    : Real64

  METHODS
    method identifier->Object
      return text

    method size->XY
      return MenuManager.img_button.size

    method hitbox->Box
      return Box(XY(0,0), MenuManager.img_button.size).cropped(3)

    method init (text)
      cur_scale = NORMAL
      target_scale = NORMAL

    method draw (position : XY)
      #MenuManager.img_button.anchor = Anchor.CENTER
      local size = this.size
      MenuManager.img_button.scale = cur_scale
      local s = MenuManager.img_button.size
      s -= MenuManager.img_button.size * cur_scale
      position += s * .5
      size *= cur_scale
      MenuManager.img_button.draw(position)
      MenuManager.font.scale = cur_scale
      MenuManager.font.color = Color.BLACK
      MenuManager.font.draw(text, position + size / 2 + XY(2,2))
      MenuManager.font.color = Color.WHITE
      MenuManager.font.draw(text, position + size / 2)
      MenuManager.img_button.scale = 1

    method update ()
      if (not locked)
        if (highlight)
          target_scale = HIGHLIGHT
        else
          target_scale = NORMAL
        endIf
      endIf

      if (cur_scale != target_scale)
        local d = 0.015
        if (cur_scale > target_scale)
          cur_scale -= d
          if (cur_scale < target_scale)
            cur_scale = target_scale
          endIf
        else
          cur_scale += d
          if (cur_scale > target_scale)
            cur_scale = target_scale
          endIf
        endIf
      endIf

    method on_in
      highlight = true
      locked = false
    method on_out
      highlight = false
      locked = false
    method on_down
      highlight = true
      locked = false
    method on_up
      highlight = false
      target_scale = NORMAL
      locked = true
endClass

class MenuText : MenuItem
  PROPERTIES
    text : String

  METHODS
    method init (text)

    method identifier->Object
      return text

    method size->XY
      return MenuManager.font.measure( text )

    method hitbox->Box
      return Box( size )

    method draw (position : XY)
      local font = MenuManager.font
      local old_anchor = font.anchor
      font.anchor = Anchor.CENTER
      font.scale = 1.0
      font.color = Color.BLACK
      font.draw(text, position.yv + XY(512,0) + XY(2,2))
      font.color = Color.WHITE
      font.draw(text, position.yv + XY(512,0))
      font.anchor = old_anchor
endClass


class MenuEntry(item:MenuItem)
  PROPERTIES
    position : XY
endClass

class MenuManager [singleton]
  PROPERTIES
    img_button = Image("button_blank.png").[ anchor=Anchor.TOP_LEFT ]
    font       = Font("font_Book Antiqua_37_bold.png")
    on_select  = SoundEffect("sfx_tick", 1)
    highlight  = SoundEffect("sfx_tock", 3)

  METHODS
    method init
      #font.anchor = Anchor(XY(0, -3), Anchor.CENTER)
      font.anchor = Anchor.CENTER
      font.spacing_adjustment = -6
endClass

class Menu
  PROPERTIES
    entries    = MenuEntry[]

    ###stagger : Logical
    horizontal : Logical
    box        : Box
    justify    = 1   # 0->Left 1->Center 2->Right

    target     : MenuHost

    current_offset = XY.zero : XY
    target_offset  = XY.zero : XY

    _dirty = true : Logical
    _current      : MenuEntry

  METHODS
    method fly_out_left
      target_offset = Display.at(-1, 0)

    method fly_out_bottom
      target_offset = Display.at(0, 1)

    method fly_in_right
      target_offset = current_offset
      current_offset = Display.at(1, 0)

    method fly_in_bottom
      target_offset = current_offset
      current_offset = Display.at(0, 1)

    method init ()
      box = Display.bounds.cropped(100)

    method init (box)

    method justify_left
      justify = 0
      _dirty = true

    method justify_right
      justify = 2
      _dirty = true

    method justify_centered
      justify = 1
      _dirty = true

    method add (item : MenuItem)
      _dirty = true
      entries.add(MenuEntry(item))

    method _getmaj (v : XY)->Real64
      if (horizontal) return v.x
      return v.y

    method _getmin (v : XY)->Real64
      if (horizontal) return v.y
      return v.x

    method _vec (minor : Real64, major : Real64)->XY
      if (horizontal) return XY(major, minor)
      return XY(minor, major)

    method refresh
      if (not _dirty) return
      _dirty = false

      local total_major = 0.0
      forEach (entry in entries)
        total_major += _getmaj(entry.item.size)
      endForEach
      local leftover_major = _getmaj(box.size) - total_major
      local padding_major = leftover_major / 1.or_larger(entries.count - 1)

      total_major = 0
      local i = 0
      forEach (entry in entries)
        local minor = _getmin(box.position)
        which (justify)
          case 0:
            # Nothing
          case 1:
            minor = _getmin(box.center) - _getmin(entry.item.size) / 2
          case 2:
            # Right
            minor = _getmin(box.position) - _getmin(entry.item.size)
        endWhich
        entry.position = _vec(minor, _getmaj(box.position) + total_major + i * padding_major)
        total_major += _getmaj(entry.item.size)
        i++
      endForEach

    method update
      current_offset = current_offset * .8 + target_offset * .2
      #if (current_offset.x < 5) current_offset = XY(0, current_offset.y)
      #if (current_offset.y < 5) current_offset = XY(current_offset.x, 0)

      refresh
      forEach (entry in entries)
        entry.item.update
      endForEach

    method update_current (check_button_state = true : Logical)
      local entry = find_under(check_button_state)
      if (entry is null)
        if (_current?)
          _current.item.on_out
          _current = null
        endIf
        return
      endIf
      if (_current is not entry)
        if (_current?) _current.item.on_out
        _current = entry
        _current.item.on_in
        #MenuManager.highlight.play
      endIf

    method on (e : PointerEvent)
      if (e.is_press)
        update_current
        if (_current?)
          _current.item.on_down
        endIf
      elseIf (e.is_release)
        update_current(false)
        if (_current?)
          _current.item.on_up
          if (target?) target.menu_selected(_current, _current.item.identifier)
          MenuManager.on_select.play
          _current = null
        endIf
      elseIf (e.is_move)
        update_current
      endIf

    method find_under (check_button_state = true : Logical)->MenuEntry
      if (check_button_state)
        if (Pointer.press_count == 0) return null
      endIf

      forEach (entry in entries)
        local p = entry.position + current_offset
        if ((entry.item.hitbox + p).contains(Pointer.position))
          return entry
        endIf
      endForEach
      return null

      #method current_offset->XY
      #  return XY.zero

    method draw
      refresh
      update_current
      forEach (entry in entries)
        local p = entry.position + current_offset
        entry.item.draw(p)
      endForEach
      #{
      local current = _current
      local hit = false
      forEach (entry in entries)
        local p = entry.position
        if ((entry.item.hitbox + p).contains(Input.mouse_position))
          hit = true
          if (entry is not current)
            if (current?)
              current.item.on_out
            endIf
            current = entry
            current.item.on_in
          endIf
        endIf
        entry.item.draw(p)
      endForEach
      if (hit)
        _current = current
      else
        if (_current?)
          _current.item.on_out
        endIf
        _current = null
      endIf
      }#

    method set_offset( offset:XY )
      current_offset = offset
      target_offset = offset
endClass

class TreeGame : ScreenState<<GameScreen>>, MyScreen [singleton]
  GLOBAL PROPERTIES
    invert_swipe = false

  PROPERTIES
    flake_button = Image("flake_button.png").[ anchor=Anchor.TOP_LEFT ]
    spark = Image("twinkle.png")
    tree : Tree
    ticks : Int32
    bg = Image("new_bg.jpg").[ anchor=Anchor.TOP_LEFT ]
    treepic = Image("new_tree_base.png")
    starpic = Image("star_2019.png").[ anchor=Anchor.TOP_LEFT ]
    tree_sparkle_map = Bitmap(Plasmacore.data_file("tree_sparkle_map.png"))
    star_sparkle_map = Bitmap(Plasmacore.data_file("star_sparkle_map.png"))
    sparks   = MultiDrawable()
    tree_sparkles = MultiDrawable()
    star_sparkles = MultiDrawable()

    timer_font = Font("font_Book Antiqua_37_bold.png")

    last_button : Int32
    last_position : XY

    last_slow_timer : Int64

  METHODS
    method init
      spark.anchor = Anchor.CENTER
      spark.render_mode = RenderMode.ADDITIVE_IMAGE

      timer_font.anchor = Anchor.TOP_RIGHT
      timer_font.spacing_adjustment = -1
      timer_font.make_numerals_monospace

      treepic.position = XY(1024,768) / 2

      SFX # cache SFX
      FlakeManager
      Display.background_color = Color(0,0,0)
      #Display.background_color = Color(255,255,255)


    method on_resize

    method random_on_map (map : Bitmap)->XY
      while (true)
        local p = XY(Random.int32(0, map.size.x), Random.int32(0, map.size.y))
        local pixel = map.get(p.x, p.y).argb : Int32
        if ((pixel & 0xFFffFF) == 0)
          return p
        endIf
      endWhile

    method random_star_sparkle
      local p = random_on_map(star_sparkle_map)
      TreeGame.spark.color = HSB(360*.1666, Random.real64(0,1), 1)->Color

      local s = SimpleSpriteAnimation(TreeGame.spark, 900)

      local d = Random.real64(40, 90)
      if (Random.real64 < .5) d *= -1
      s.setup_rotation_degrees(Degrees(0), Degrees(d))
      s.setup_scale(0, 1.5, SimpleSpriteAnimation.OSCILLATE_SIN_SHARP)
      s.setup_fade(0, 1, SimpleSpriteAnimation.OSCILLATE_SIN)

      p = XY(1024,768) / tree_sparkle_map.size * p
      s.setup_position(p)

      star_sparkles.add(s)

    method random_sparkle
      if (Random.real64 < .5)
        random_star_sparkle
      else
        random_tree_sparkle
      endIf


    method random_tree_sparkle
      local p = random_on_map(tree_sparkle_map)
      TreeGame.spark.color = HSB(360*Random.real64, Random.real64(.5,.8), Random.real64(.8,1))->Color
      local s = OverexposedSimpleSpriteAnimation(TreeGame.spark, 900)

      local d = Random.real64(40, 90)
      if (Random.real64 < .5) d *= -1
      s.setup_rotation_degrees(Degrees(0), Degrees(d))
      s.setup_scale(0, 1.5, SimpleSpriteAnimation.OSCILLATE_SIN_SHARP)
      s.setup_fade(0, 1, SimpleSpriteAnimation.OSCILLATE_SIN)

      p = XY(1024,768) / tree_sparkle_map.size * p
      s.setup_position(p)

      tree_sparkles.add(s)

    method on_start
      Music.tick
      tree = Tree(17)
      tree.resume
      last_slow_timer = running_ms
      on_resize

    method on_resume
      tree.resume
      last_slow_timer = running_ms

    method check_dead->Logical
      #println(running_ms - last_slow_timer)
      local dead = false
      if (running_ms - last_slow_timer > 5000)
        Global.time_offset -= (running_ms - last_slow_timer)
        if (not tree.solved)
          tree.pause(last_slow_timer + 2000)
          TransitionToPushState( PauseMenu )
          dead = true
        endIf
      endIf
      last_slow_timer = running_ms
      return dead

    method on_update
      tree.update()
      ticks++
      if ((ticks % 60) == 0)
        ticks = 0
        slow_timer
      endIf

    method slow_timer
      # Called every second or two
      Music.tick

    method on_draw
      if (check_dead)
        prior.on_draw
        return
      endIf
      #SystemFont.draw( ""+Input.mouse_position, Display.center )
      Graphics.draw_background
      Graphics.scale_to_fill( Anchor.BOTTOM )
      FlakeManager.draw
      Graphics.apply_tree_transform( tree )

      screen.apply_transition_offset

      treepic.draw
      tree.draw
      tree.make_sparks
      if (tree.solved)
        if (Random.real64 < .1) random_tree_sparkle
      else
        if (Random.real64 < .001) random_tree_sparkle
      endIf
      tree_sparkles.draw
      sparks.draw

      SystemFont.anchor = Anchor.CENTER
      if (tree.solved)
        if (Random.real64 < .04) random_star_sparkle
        local p = (running_ms - tree.solved_ms) / 400.0 : Real64
        if (p > 1) p = 1
        starpic.color = Color(255,255,255,255*p)
        starpic.draw(XY(380,-54))
        star_sparkles.draw
      endIf

      Display.clear_scale

      timer_font.anchor = Anchor.TOP_RIGHT

      local safe_area = Display.safe_area
      local pos = safe_area.top_right + XY(-6, 1)

      screen.apply_transition_offset

      timer_font.scale = Display.density
      timer_font.color = Color.BLACK
      timer_font.draw(tree.time_string, pos + XY(2,2))
      timer_font.color = Color.WHITE
      timer_font.draw(tree.time_string, pos)

      local button = flake_button
      button.scale = Display.density
      button.rotation = Radians(0)
      button.color = Color(0,0,0,192)
      #button.draw(XY(42, 42))
      button.draw(safe_area.top_left+XY(7, 5))
      button.color = Color.WHITE
      button.draw(safe_area.top_left+XY(5, 3))
      #button.draw(XY(40, 40))

      Graphics.apply_tree_transform( tree )
      # Leave this transform in place to handle input events between updates


    method on(e : PointerEvent)
      if (e.is_press)
        local abs_pos = e.position - Display.safe_area.position
        if (abs_pos.x < flake_button.size.x and abs_pos.y < flake_button.size.y)
          MenuManager.on_select.play
          tree.pause
          TransitionToPushState( PauseMenu, TRANSITION_TIME, &exit_vector=XY(0,1) )
        endIf
        last_button = e.index
        last_position = e.position

      elseIf (e.is_release)
        if (e.index == last_button)
          local x = e.position.x - last_position.x
          local y = e.position.y  - last_position.y

          #println(x + " " + y)


          if (x.abs < 15) x = 0
          #else x = x.sign
          if (y.abs < 15) y = 0
          #else y = y.sign

          #if (y == 0) y = x
          #if (x == 0) x = y

          if (x.abs * .66 > y.abs)     y = x
          elseIf (y.abs * .66 > x.abs) x = y

          if (x == y and y == 0)
            if (e.is_release_right)
              x = -1
              y = -1
            endIf
          endIf

          x = x.sign
          y = y.sign

          if (x == -1 and y == 1) y = -1

          if (x == y)
            if (invert_swipe xor not e.is_press_left) x *= -1
            if (Keyboard.is_shift_pressed and x == 0) x = -1
            local pos = last_position * .8 + e.position * .2
            tree.click(pos, x > 0)
          endIf
        endIf
      endIf

    method on(e : KeyEvent)
      if (e.is_press)
        #if (e.is_press(Keycode.ESCAPE)) System.exit
        if (e.is_press(Keycode.X)) tree.click(Pointer.position, false)
        if (e.is_press(Keycode.Z)) tree.click(Pointer.position, true)
      endIf
endClass


class Pair<<$AType, $BType>>
  PROPERTIES
    a : $AType
    b : $BType

  METHODS
    method init
      # Nothing

    method init (_a : $AType, _b : $BType)
      a = _a
      b = _b

    method hash_code->Int32
      return a.hash_code | b.hash_code

    method to->String
      return "<Pair: $, $>" (a, b)
endClass

class LitSets
  PROPERTIES
    #    lit() : HashSet<<Tile>>
    #    unlit() : HashSet<<Tile>>
    lit     = Tile[]
    unlit   = Tile[]
  METHODS
    method init
endClass

augment Global
  PROPERTIES
    time_offset : Int64
  METHODS
    method sinr (r : Real64)->Real64
      return Radians(r).sin
    method running_ms->Int64
      return Int64(System.time*1000) + time_offset
    method time_ms->Int64
      return Int64(System.time*1000)
endAugment

class FlakeManager [singleton]
  PROPERTIES
    num_flakes    = 25
    add_delay_min = 500
    add_delay_max = 2500

    flakes = Flake[]
    images = Image[]

    next_add : Int64

  METHODS
    method init
      forEach (i in 1..6)
        images.add(Image("flakes/flake$.png" (i)))
        images.last.anchor = Anchor.CENTER
      endForEach

      flakes.add(Flake())
      next_add = time_ms + Random.int32(add_delay_min, add_delay_max)

    method draw
      forEach (i in 0..flakes.count-1)
        local flake = flakes[i]
        local p = flake.pos
        local t = flake.t

        p += (flake.vel * t)

        p += XY(Radians(2 * pi * t / flake.sway_period + 2 * pi * flake.sway_offset).sin * flake.sway_amount, 0)
        p += XY(Radians(2 * pi * t / flake.sway_period2 + 2 * pi * flake.sway_offset2).sin * flake.sway_amount2, 0)

        flake.image.scale = flake.size
        flake.image.color = flake.color
        flake.image.rotation = flake.rotation * t
        if (p.y - flake.image.size.y > Display.bounds.y2)
          flakes[i] = Flake()
        else
          flake.image.draw(p)
        endIf
      endForEach

      if (flakes.count < num_flakes)
        if (next_add <= time_ms)
          next_add = time_ms + Random.int32(add_delay_min, add_delay_max)
          flakes.add(Flake())
        endIf
      endIf
endClass

class Flake
  PROPERTIES
    rotation : Degrees
    pos = XY(Random.int32(-400, Display.size.x), -150)
    size = Random.real64(.5, 1) : Real64
    image = FlakeManager.images.random() : Image
    vel = XY(Random.real64(5, 15), Random.real64(10, 25))
    color = Color(255,255,255,Random.real64(.7,1) * 255)
    start_ms = time_ms : Real64

    sway_amount = Random.real64(5, 15) : Real64
    sway_period = Random.real64(4, 6) : Real64
    sway_offset = Random.real64(0, .25) : Real64

    sway_amount2 = Random.real64(5, 10) : Real64
    sway_period2 = Random.real64(6, 12) : Real64
    sway_offset2 = Random.real64(0, .5) : Real64
  METHODS
    method t->Real64
      return (time_ms - start_ms) / 1000.0
    method init
      while (rotation.value.abs < 8)
        rotation = Degrees(Random.real64(-10, 25))
      endWhile

endClass

class Tree
  PROPERTIES
    solved     = false : Logical
    draw_pos   = XY(70-23,110+80)
    width      : Int32 # max width
    source     : Tile
    num_pieces : Int32 # number of lightable pieces
    started_ms = running_ms : Int64
    solved_ms  : Int64

    pause_start = -1 : Int64

    zoom = EasedValue<<Real64>>( 0, 2 )

    t : Tile[][]

  METHODS
    method pause (time = running_ms : Int64)
      if (solved) return
      if (pause_start != -1) return

      pause_start = time

    method resume
      if (pause_start == -1) return

      started_ms += (running_ms - pause_start)

      pause_start = -1

    method set_solved (v : Logical)
      @solved = v
      if (v)
        solved_ms = running_ms
        SFX.jingle.play
        zoom.target_value = 0
      endIf

    method pad (n : Int64)->String
      if (n < 10) return "0" + n
      return "" + n

    method time_string->String
      local sec = 0
      if (solved)
        sec = ((solved_ms - started_ms) / 1000)
      else
        sec = ((running_ms - started_ms) / 1000)
      endIf
      return pad(sec / 60) + ":" + pad(sec % 60)

    method get (x : Int32, y : Int32)->Tile
      if (y < 0) return null
      if (y >= t.count) return null
      local d = (t.last.count - t[y].count) / 2
      x = x - d
      if (x < 0) return null
      if (x >= t[y].count) return null
      return t[y][x]

    method height->Int32
      return t.count

    method size->Int32
      return (width - 1) / 2

    method make_row (w : Int32)->Tile[]
      local o = (width - w) / 2 : Int32
      local r = Tile[]
      forEach (i in 0..w-1)
        r.add(Tile(this, o + i))
      endForEach
      return r

    method init (base_width : Int32)
      width = base_width

      t = Tile[][]
      t.add(make_row(width))
      t[0][size].lit = true
      t[0][size].ready = true
      t[0][size].value = 1
      source = t[0][size]
      source.cur_lit = 1
      source.target_lit = 1

      t.insert(make_row(width), 0)
      local s = width : Int32
      while (s >= 3)
        t.insert(make_row(s), 0)
        s = s - 2
      endWhile

      num_pieces = 1 # 1 for the root piece
      local y = 0 : Int32
      forEach (r in t)
        if (r is not t.last) num_pieces += r.count
        forEach (c in r)
          c.y = y
        endForEach
        y = y + 1
      endForEach

      reset
      randomize

      relight
      zoom.target_value = 1.0

    method reset
      local tiles = Tile[]
      forEach (r in t)
        if (r is t.last) escapeForEach
        forEach (c in r)
          tiles.add(c)
        endForEach
      endForEach

      while (tiles.count > 0)
        local c = tiles.random()
        if (c.try_connect)
          tiles.remove(c)
        endIf
      endWhile

    method click (pos : XY, alternate : Logical)
      if (solved) return
      pos = pos - draw_pos
      local x = pos.x + TileImages.imgs[0].size.x / 2 : Int32
      local y = pos.y + TileImages.imgs[0].size.y / 2 : Int32
      x /= TileImages.imgs[0].size.x
      y /= TileImages.imgs[0].size.y
      local tile = get(x, y)
      if (tile is null) return
      if (tile.y == height - 1) return

      tile.rotate(alternate)

    method randomize
      forEach (r in t)
        forEach (c in r)
          if (c is not source)
            if (not Keyboard.is_shift_pressed)
              c.value = c.ror(c.value, Random.int32(0,3))
            endIf
          endIf
        endForEach
      endForEach
      if (Keyboard.is_shift_pressed)
        local c = t[0][0]
        c.value = c.ror(c.value, 1)
      endIf

    method lit_and_unlit_sets (unlight = false : Logical)->LitSets
      local o = LitSets()

      forEach (r in t)
        if (not (r is t.last))
          forEach (c in r)
            if (c is not source)
              if (c.lit)
                o.lit.add(c)
                if (unlight)
                  c.lit = false
                  c.spark_dirs = 0
                endIf
              else
                o.unlit.add(c)
              endIf
            endIf
          endForEach
        endIf
      endForEach

      return o

    method relight ()
      #method relight (Int64 finish_time)
      local prev = lit_and_unlit_sets(true)
      source.spark_dirs = 0

      solved = false
      source.spread

      local cur = lit_and_unlit_sets
      #cur.lit.intersect(prev.unlit)
      #cur.unlit.intersect(prev.lit)
      # lit and unlit are now just the changed ones
      forEach (c in prev.lit)
        if (cur.lit.contains(c)) cur.lit.remove(c)
      endForEach
      forEach (c in prev.unlit)
        if (cur.unlit.contains(c)) cur.unlit.remove(c)
      endForEach

      forEach (c in cur.lit)
        c.target_lit = 1
        which (c.index)
          case 1,2,4,8:
#XXXXXXXX
        endWhich
      endForEach
      forEach (c in cur.unlit)
        c.target_lit = 0
      endForEach

    method update
      forEach (r in t)
        forEach (c in r)
          c.update
        endForEach
      endForEach

    method draw
      forEach (r in t)
        forEach (c in r)
          c.draw
        endForEach
      endForEach

    method make_sparks
      forEach (r in t)
        forEach (c in r)
          c.make_sparks
        endForEach
      endForEach
endClass

class Tile
  PROPERTIES
    tree : Tree
    x : Int32
    y : Int32
    lit : Logical
    ready: Logical
    value :  Int32
    rotation : Real64
    index = -1: Int32

    target_lit = 0 : Real64
    cur_lit : Real64
    lit_start : Int64
    lit_duration : Int32

    cur_rot : Real64
    rot_amount : Real64

    hue = Random.real64 : Real64
    sat1 = Random.real64(.9,1) : Real64
    sat2 = Random.real64(.9,1) : Real64
    hue_var = Random.real64(0,.1) : Real64

    spark_dirs : Int32
  METHODS
    method hash_code->Int32
      return (x:>>:16) | y

    method set_lit (v : Logical)
      if (v != @lit)
        if (target_lit != cur_lit)
          #double p = cur_lit
          #if (not lit) p = 1 - p

        endIf
      endIf
      @lit = v

    method rotation->Degrees
      if (not rotating) return Degrees(@rotation)

      return Degrees(cur_rot)

    method rotating->Logical
      return cur_rot != @rotation

    method rotate (left : Logical)
      #SFX.swish1.play
      if (left)
        @value = rol(value, 1)
      else
        @value = ror(value, 1)
      endIf


      local ora = rot_amount

      rot_amount = 10
      if (left)
        @rotation -= 90
        rot_amount *= -1
      else
        @rotation += 90
      endIf

      if (rot_amount.sign == ora.sign)
        rot_amount += ora * .5
      endIf

      tree.relight
      local good = false
      if (lit?)
        good = true
        forEach (i in 0..3)
          local b = 1 :<<: i
          if ((b & value) > 0)
            local n = neighbor(b)
            if (n is null or ((n.value & opp(b)) == 0))
              good = false
              escapeForEach
            endIf
          endIf
        endForEach
      endIf
      if (good)
        SFX.tambourine.play
      else
        SFX.swish1.play
      endIf

    method rol (b : Int32, n=1 : Int32)->Int32
      if (n == 0) return b & 15
      return rol( ((b & 1):<<:3) | (b:>>:1), n - 1)

    method ror (b : Int32, n=1 : Int32)->Int32
      if (n == 0) return b & 15
      return ror(((b & 8):>>:3) | (b:<<:1), n - 1)

    method neighbor (v : Int32)->Tile
      which (v)
        case 1: return tree.get(x, y-1)
        case 2: return tree.get(x+1, y)
        case 4: return tree.get(x, y+1)
        case 8: return tree.get(x-1, y)
      endWhich
      return null

    method try_connect->Logical
      if (ready) return false
      local dirs = [1,2,4,8]
      dirs.shuffle()
      forEach (d in dirs)
        local n = neighbor(d)
        if (n is not null)
          if (n.ready)
            value = value | d
            ready = true
            n.value = n.value | opp(d)
            return true
          endIf
        endIf
      endForEach

      return false

    method init (parent : Tree, x_ : Int32)
      tree = parent
      x = x_
      lit = false
      ready = false
      value = 0

    method update
      cur_lit = cur_lit * .95 + target_lit * .05

      if (rot_amount.abs > 5)
        rot_amount *= .925
      endIf

      if (@rotation != cur_rot)
        cur_rot = cur_rot + rot_amount
        if (rot_amount > 0)
          if (cur_rot >= @rotation)
            if (@rotation > 360) @rotation -= 360
            cur_rot = @rotation
            rot_amount = 0
            tree.relight
          endIf
        elseIf (rot_amount < 0)
          if (cur_rot <= @rotation)
            if (@rotation < 0) @rotation += 360
            cur_rot = @rotation
            rot_amount = 0
            tree.relight
          endIf
        endIf
      endIf


    method draw ()
      if (index == -1) return
      local img = TileImages.imgs[index]
      local finish = rotating : Logical
      img.rotation = rotation
      finish = finish and not rotating
      local sx = img.size.x : Int32
      local sy = img.size.y : Int32
      local alpha = 255 : Int32
      if (tree.solved)
        local p = (running_ms - tree.solved_ms) / 1000.0 : Real64
        if (p > .75) p = .75
        p = 1 - p
        alpha = p * 255
      endIf

        #if (lit)
        img.color = Color(255 * cur_lit,255 * cur_lit,64 * cur_lit, alpha)
        #else
        #img.color = Color(0,0,0)
        #endIf
      img.draw( XY(x * sx + tree.draw_pos.x, y * sy + tree.draw_pos.y) )
      if  (index == 0 and this is not tree.source)
        TileImages.bulb.color = HSB(360*hue, sat1, .25 + .75 * cur_lit)->Color
        TileImages.bulb.render_mode = RenderMode.ALPHA_IMAGE
        TileImages.bulb.draw(XY(x * sx + tree.draw_pos.x, y * sy + tree.draw_pos.y))
        TileImages.bulb.color = HSB(360*hue+hue_var, sat2, .5 * cur_lit)->Color
        TileImages.bulb.render_mode = RenderMode.ADDITIVE_IMAGE
        TileImages.bulb.draw(XY(x * sx + tree.draw_pos.x, y * sy + tree.draw_pos.y))
      endIf

      if (finish) #FIX: only once per frame!
        tree.relight
      endIf

    method make_sparks ()
      if (spark_dirs == 0) return
      if (rotating) return

      local b = 1 : Int32
      local s = spark_dirs
      while (s > 0)
        if ((s & 1) == 1)
          spark(b)
        endIf
        b = b :<<: 1
        s = s :>>: 1
      endWhile

    method spark (d : Int32)
      if (Random.real64 < 0.96) return

      local p = XY(0, 0)
      local o = XY(0, 0)
      which (d)
        case 1:
          p = XY(0, -1)
          o = XY(1, 0)
        case 2:
          p = XY(1, 0)
          o = XY(0, 1)
        case 4:
          p = XY(0, 1)
          o = XY(1, 0)
        case 8:
          p = XY(-1, 0)
          o = XY(0, 1)
      endWhich
      local v = p
      p *= (TileImages.imgs[0].size * .5)
      local shift = Random.real64(-6,6)
      p += o * shift

      local dir = -1 : Real64
      if (shift > 0) dir = -dir
      if (d == 4 or d == 8) dir = -dir

      p += XY(x, y) * TileImages.imgs[0].size + tree.draw_pos

      TreeGame.spark.color = Color(255, 255, 0)
      local s = SimpleSpriteAnimation(TreeGame.spark, 150)

      v = v.rotated(Degrees(Random.real64(0,45)*dir)) * TileImages.imgs[0].size * 0.25
      s.setup_position_relative(p, v)
      s.setup_rotation_degrees(Degrees(0), Degrees(Random.real64(-10,10)))
      s.setup_scale(1, 0.6)
      s.setup_fade(cur_lit, 0)

      TreeGame.sparks.add(s)

    method opp (v : Int32)->Int32
      return ror(v, 2)

    method spread ()->Int32

      if (lit? == false) return 0
      if (rotating) return 0

      local children = 0 : Int32
      children++ # Myself

      forEach (i in 0..3)
        local b = 1 :<<: i
        if ((b & value) > 0)
          local n = neighbor(b)
          if (n is not null)
            if ((n.value & opp(b)) > 0)
              if (n.lit? == false)
                n.lit = true
                children += n.spread
              endIf
            else
              children = 0 # can't be solved!
              spark_dirs |= b
              spark(b)
            endIf
          else
            children = 0 # can't be solved!
            spark_dirs |= b
            spark(b)
          endIf
        endIf
      endForEach

      if (children >= tree.num_pieces)
        tree.solved = true
      endIf

      return children

    method set_value (v : Int32)
      @value = v
      #if (ready) spread

      local rot = 0 : Int32
      which (v)
        case 1,2,4,8:
          index = 0
          if (v > 1) rot = rot + 1
          if (v > 2) rot = rot + 1
          if (v > 4) rot = rot + 1
        case 3, 6, 9, 12:
          index = 1
          if (v == 6) rot = 1
          if (v == 12) rot = 2
          if (v == 9) rot = 3
        case 5, 10:
          index = 2
          if (v > 5) rot = rot + 1
        case 7, 11, 13, 14:
          index = 3
          if (v == 11) rot = 3
          if (v == 13) rot = 2
          if (v == 14) rot = 1
        case 15:
          index = 4
        others:
          index = -1
      endWhich
      rotation = (rot * 90)
      cur_rot = @rotation

endClass

class TileImages [singleton]
  PROPERTIES
    imgs = Image[]
    bulb : Image
  METHODS
    method add_img (name : String)
      local img = Image(name)
      imgs.add(img)
      img.anchor = Anchor.CENTER

    method init
      bulb = Image("bulb.png")
      bulb.anchor = Anchor.CENTER
      add_img("1.png")
      add_img("3.png")
      add_img("5.png")
      add_img("7.png")
      add_img("15.png")

endClass

class Music [singleton]
  PROPERTIES
    #path = "./music" : String
    volume : Real64
    paused = false: Logical

    tracks = Sound[]
    names  = String[]
    index = -1 : Int32
    real_volume : Real64
    is_paused = true: Logical

  METHODS
    method init
      #local File dir = File(".")
      #dir = File(dir.absolute_filepath, "sounds")
      #dir = File(dir.absolute_filepath, "music")
      local files = [
        "music/dance-of-the-sugar-plum-faries",
        "music/jingle-bells-slow-mix",
        "music/oh-christmas-tree",
        "music/silent-night" ] : String[]

      forEach (entry in files) #dir.directory_listing)
        #tracks.add(Sound("music/" + entry))
        tracks.add(Sound(entry,&is_music))
        local words = entry.replacing("-", " ").before_last('.').split(' ')
        local n = StringBuilder()
        forEach (word in words)
          n.print(word.capitalized)
          n.print(" ")
        endForEach
        names.add(n.to_String.trimmed)
      endForEach

      local order = (0..(tracks.count - 1))->Int32[]
      order.shuffle
      forEach (o in order)
        names.add(names[o])
        tracks.add(tracks[o])
      endForEach
      loop (order.count)
        names.remove_at(0)
        tracks.remove_at(0)
      endLoop

    method toggle_pause
      paused = not paused

    method next_track
      if (tracks.count == 0)
        index = -1
        return
      endIf

      if (index >= 0)
        tracks[index].stop
      endIf

      index++
      if (index >= tracks.count) index = 0
      tracks[index].play
      #println("Playing: " + names[index])

      paused = false
      is_paused = false

    method tick->Logical
      if (paused != is_paused)
        is_paused = paused
        if (paused)
          if (index >= 0)
            tracks[index].pause
          endIf
        else
          if (index >= 0)
            tracks[index].play
          else
            next_track
          endIf
        endIf
        return true
      endIf

      if (paused) return true

      if (index < 0)
        next_track
      else
        if (not tracks[index].is_playing)
          tracks[index].stop
          next_track
        endIf
      endIf

      return true

endClass

class SFX [singleton]
  PROPERTIES
    enabled = true : Logical
    swish1     = SoundEffect("sfx_swish1", 5)
    tambourine = SoundEffect("sfx_tambourine", 5)
    swish2     = SoundEffect("sfx_swish2", 5)
    click1     = SoundEffect("sfx_click1", 5)
    jingle     = SoundEffect("sfx_jingle", 1)
endClass

class SoundEffect : SoundGroup
  METHODS
    method play->SoundGroup
      if (SFX.enabled) return prior.play
      return this
endClass

class Drawable [aspect]
  METHODS
    method draw->Logical [abstract]
endClass

class MultiDrawable : Drawable
  PROPERTIES
    children       : Drawable[]
    die_when_empty : Logical

    _removed = Drawable[]
    _drawing = false
  METHODS
    method init ()
      children = Drawable[]

    method remove (d : Drawable)
      if (_drawing)
        _removed.add(d)
      else
        try
          children.remove(d)
        catch (e : Exception)
        endTry
      endIf

    method add (d : Drawable)
      children.add(d)

    method draw->Logical
      local removed : Int32[]
      _drawing = true
      local r  = false
      forEach (d at i in children)
        try
          r = d.draw
        catch (e : Exception)
          println(e.to_String)
          r = false
        endTry
        if (r == false)
          ensure removed
          removed.add(i)
        endIf
      endForEach
      _drawing = false
      if (removed)
        forEach (i in removed.count-1 downTo 0)
          children.remove_at(removed[i])
        endForEach
      endIf
      if (_removed.count > 0)
        forEach (drawable in _removed)
          children.remove(drawable)
        endForEach
        _removed.clear
      endIf

      if (die_when_empty and (children.count == 0))
        return false
      endIf
      return true
endClass

class OverexposedSimpleSpriteAnimation : SimpleSpriteAnimation
  METHODS
    method draw->Logical
      image.render_mode = RenderMode.ALPHA_IMAGE
      prior.draw
      image.render_mode = RenderMode.ADDITIVE_IMAGE  # 'overexpose'
      return prior.draw
endClass

class SimpleSpriteAnimation : Drawable
  GLOBAL PROPERTIES
    OPACITY             = 0 : Int32
    ANGLE               = 1 : Int32
    SCALE               = 2 : Int32
    XCOORD              = 3 : Int32
    YCOORD              = 4 : Int32
    NONE                = 0 : Int32
    LINEAR              = 1 : Int32
    SIN                 = 2 : Int32
    SIN_SHARP           = 3 : Int32
    OSCILLATE_LINEAR    = 4 : Int32
    OSCILLATE_SIN       = 5 : Int32
    OSCILLATE_SIN_SHARP = 6 : Int32

  PROPERTIES
    clock  = Stopwatch()

    values = Dim<<Real64>>( 5, 2 )

    meth   = Dim<<Real64>>( 5 )

    color : Color

    # Amount of gravity per second
    gravity_direction = XY(0,0)

    # Amount of drift per second
    drift_direction = XY(0,0)

    duration_ms : Real64
    start_time : Real64
    cyclical = false
    stopped = false

    persist = false # What to do when stopped / finished

    image : Image

    num_deaths = 0 : Int32
    max_deaths = 0 : Int32

    temp_angle : Radians

  METHODS

    #{
  LINEAR:
    /
   /
  /

  SIN:
    _
   /
  |

  SIN_SHARP:

     |
   _/

  OSCILLATE_LINEAR:
   /\
  /  \

  OSCILLATE_SIN:
    __
   /  \
  |    |

  OSCILLATE_SIN_SHARP:

    |
  _/ \_
  }#

    method remove
      stop
      persist = false

    method init(image, duration_ms)
      init(image,duration_ms,XY(0,0))

    method init(image, duration_ms, coord : XY)

      reset

      values[SCALE][0] = 1
      values[OPACITY][0] = 1
      values[XCOORD][0] = coord.x
      values[YCOORD][0] = coord.y

      color = image.colors.a

    method stop
      stopped = true

  # ------------------------------------------------------------------------

  #{*  Sets how opacity changes over time for this sprite.
    *  Opacities are measured by a floating point value between
    *  0 (fully transparent) and 1 (fully opaque).
    *  @param start_opacity The initial opacity
    *  @param end_opacity The final opacity
    }#
    method setup_fade(start_opacity : Real64, end_opacity : Real64, interpolation_type : Int32)
      values[OPACITY][0] = start_opacity
      values[OPACITY][1] = end_opacity
      meth[OPACITY] = interpolation_type

    method setup_rotation(start_radians : Radians, end_radians : Radians, interpolation_type : Int32)
      values[ANGLE][0] = start_radians.value
      values[ANGLE][1] = end_radians.value
      meth[ANGLE] = interpolation_type

    method setup_rotation_degrees(start_degrees : Radians, end_degrees : Radians, interpolation_type : Int32)
      setup_rotation(start_degrees * pi / 180, end_degrees * pi / 180, interpolation_type)

    method setup_scale(start_factor : Real64, end_factor : Real64, interpolation_type : Int32)
      values[SCALE][0] = start_factor
      values[SCALE][1] = end_factor
      meth[SCALE] = interpolation_type

    method get_fade->Real64
      local p = getP : Real64
      if (p > 1) p = 1
      return interpolate(OPACITY, p)

    method get_angle->Real64
      local p = getP : Real64
      if (p > 1) p = 1
      return interpolate(ANGLE, p) + temp_angle.value

    method get_scale->Real64
      local p = getP : Real64
      if (p > 1) p = 1
      return interpolate(SCALE, p)

    method get_start_position->XY
      return XY(interpolate(XCOORD, 0), interpolate(YCOORD, 0))

    method get_stop_position->XY
      return XY(interpolate(XCOORD, 1), interpolate(YCOORD, 1))

    method get_position->XY
      local p = getP : Real64
      if (p > 1) p = 1
      return XY(interpolate(XCOORD, p), interpolate(YCOORD, p))

    method setup_position(start_pos : XY, end_pos : XY, interpolation_type : Int32)
      values[XCOORD][0] = start_pos.x
      values[YCOORD][0] = start_pos.y
      values[XCOORD][1] = end_pos.x
      values[YCOORD][1] = end_pos.y
      meth[XCOORD] = interpolation_type
      meth[YCOORD] = interpolation_type

    method setup_position_relative(start_pos : XY, end_offset : XY, interpolation_type : Int32)
      setup_position(start_pos, start_pos + end_offset, interpolation_type)

  # ------------------------------------------------------------------------

  #{*  Sets how opacity changes over time for this sprite.
    *  Opacities are measured by a floating point value between
    *  0 (fully transparent) and 1 (fully opaque).
    *  @param start_opacity The initial opacity
    *  @param end_opacity The final opacity
    }#
    method setup_fade(start_opacity : Real64, end_opacity : Real64)
      setup_fade(start_opacity, end_opacity, LINEAR)

    method setup_fade(opacity : Real64)
      setup_fade(opacity, 0, NONE)

    method setup_rotation(start_radians : Radians, end_radians : Radians)
      setup_rotation(start_radians, end_radians, LINEAR)

    method setup_rotation_degrees(start_degrees : Degrees, end_degrees : Degrees)
      setup_rotation(start_degrees.to_Radians, end_degrees.to_Radians)

    method setup_rotation(radreal : Real64)
      setup_rotation(Radians(radreal))

    method setup_rotation(radians : Radians)
      setup_rotation(radians, Radians(0), NONE)

    method setup_rotation_degrees(degrees : Degrees)
      setup_rotation_degrees(degrees, Degrees(0), NONE)

    method setup_scale(start_factor : Real64, end_factor : Real64)
      setup_scale(start_factor, end_factor, LINEAR)

    method setup_scale(scale_factor : Real64)
      setup_scale(scale_factor, 0, NONE)

    method setup_position(start_pos : XY, end_pos : XY)
      setup_position(start_pos, end_pos, LINEAR)

    method setup_position_relative(start_pos : XY, end_offset : XY)
      setup_position(start_pos, start_pos + end_offset)

    method setup_position(pos : XY)
      setup_position(pos, XY(0,0), NONE)

  # ------------------------------------------------------------------------

    method getP->Real64
      if (cyclical) return (((clock.elapsed_ms - start_time) / duration_ms) % 1.0)->Real64
      local p = (clock.elapsed_ms - start_time) / duration_ms : Real64
      if (p < 0) p = 0
      return p

    method interpolate(switch : Int32, p : Real64)->Real64
      which(meth[switch])
        case NONE:
          return values[switch][0]
        case LINEAR:
          return(values[switch][1] - values[switch][0]) * p + values[switch][0]
        case SIN:
          local v = sinr(p * pi / 2) : Real64
          return(values[switch][1] - values[switch][0]) * v + values[switch][0]
        case SIN_SHARP:
          local v = 1 + sinr(p * pi / 2 + 3 * pi / 2) : Real64
          return(values[switch][1] - values[switch][0]) * v + values[switch][0]
        case OSCILLATE_LINEAR:
          local v = p * 2 : Real64
          if (v > 1) v = 1 - (v - 1)
          return(values[switch][1] - values[switch][0]) * v + values[switch][0]
        case OSCILLATE_SIN:
          local v = sinr(p * pi) : Real64
          return(values[switch][1] - values[switch][0]) * v + values[switch][0]
        case OSCILLATE_SIN_SHARP:
          local v = 1 - (sinr(p * pi + pi / 2)).abs : Real64
          return(values[switch][1] - values[switch][0]) * v + values[switch][0]
        others:
          println("Bad interpolation method")
          return values[switch][0]
      endWhich

    method draw->Logical
      local p : Real64

      if (stopped)
        if (not persist) return false
        p = 1
      else
        p = getP
        if (p > 1)
          die
          # die() might have reset() things, so check again...
          p = getP
          if (p > 1)
            stop
            return draw
          endIf
        endIf
      endIf

      local rotation = interpolate(ANGLE, p) : Real64
      local opacity = interpolate(OPACITY, p) : Real64
      local coord = XY(interpolate(XCOORD, p), interpolate(YCOORD, p))
      local scale = interpolate(SCALE, p) : Real64

      local t = ((clock.elapsed_ms - start_time) / 1000.0) : Real64
      # t is now how many seconds have elapsed.

      coord += drift_direction * t
      coord += gravity_direction * (t*t)

      image.rotation = Radians(rotation) + temp_angle
      image.color = color
      image.opacity = opacity

      image.scale = scale
      image.draw(coord)

      return true

    method reset
      clock.restart
      stopped = false

    method die
      # Can be overridden
      # Never called if animation is cyclical
endClass

#{
class IPhone [singleton]
 method orient(dir : Int32): native
   # 0=up-side-up, 1=right-side-up, 2=down, 3=left
endClass
}#

augment Stopwatch
  METHODS
    method elapsed_ms->Int64
      return Int64( elapsed * 1000 )
endAugment

routine Corners( x1:Real64, y1:Real64, x2:Real64, y2:Real64 )->Box
  return Box( x1, y1, x2-x1, y2-y1 )
endRoutine

class Graphics [singleton]
  METHODS
    method apply_tree_transform( tree:Tree )
      if (Display.is_phone)
        local h = 768 + ((560-768) * tree.zoom.value)
        Display.scale_to_fit( 1024, h, Anchor.BOTTOM )
        Display.offset -= XY(0,156*tree.zoom.value)
      else
        Display.scale_to_fit( 1024, 768, Anchor.BOTTOM )
      endIf

    method draw_background
      Display.clear( Color.BLACK )
      Display.clear_scale
      TreeGame.bg.scale_to_fill( Display.bounds )
      TreeGame.bg.draw

    method scale_to_fill( anchor:Anchor )
      Display.scale_to_fill( 1024, 768, anchor )

    method scale_to_fit( anchor:Anchor )
      Display.scale_to_fit( 1024, 768, anchor )
endClass

augment Display
  METHODS
    method is_phone->Logical
      if (not (System.is_ios or System.is_android)) return false
      local aspect_ratio = Display.true_size.max / Display.true_size.min
      if (System.is_ios) return (aspect_ratio >= 1.5)  # original iPhone size
      return (aspect_ratio > 1.5)  # Pixel Slate has a 1.5 aspect ratio
endAugment

